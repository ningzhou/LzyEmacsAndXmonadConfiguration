#+TITLE: AutoTool set
#+AUTHOR: zhengyu li
#+OPTIONS: ^:nil

* Step by step to construct auto-build system
** Create Project
Fistly, let's create a project directory
#+begin_src example
  test
  ├── README
  ├── configure.in
  ├── Makefile.am
  └── src
      ├── Makefile.am
      ├── client.c
      └── server.c
#+end_src

** autoscan
Run autoscan under test directory and generate configure.scan file as following
#+begin_src example
  #-*- Autoconf -*-
  # Process this file with autoconf to produce a configure script.

  AC_PREREQ([2.68])
  AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])
  AC_CONFIG_SRCDIR([src/server.c])
  AC_CONFIG_HEADERS([config.h])

  # Checks for programs.
  AC_PROG_CC

  # Checks for libraries.

  # Checks for header files.
  AC_CHECK_HEADERS([netinet/in.h stdlib.h strings.h sys/socket.h unistd.h])

  # Checks for typedefs, structures, and compiler characteristics.
  AC_TYPE_PID_T

  # Checks for library functions.
  AC_FUNC_FORK
  AC_FUNC_MALLOC
  AC_CHECK_FUNCS([bzero socket])

  AC_CONFIG_FILES([Makefile])
  AC_OUTPUT
#+end_src
after that, you should change the name of configure.scan to configure.in, in the end, you need to do
some modification and get a proper configure template file.

** config.h.in
Before running autoconf, we should run autoheader to generate config.h.in, this file will be used by
autoconf to generate config.h file. After that you can include config.h anywhere.
- example config.h.in
  #+begin_src c
    #undef HAVE_NETINET_IN_H
    #undef HAVE_STDINT_H
    #undef HAVE_STDIO_H
    #undef HAVE_STDLIB_H
    #undef HAVE_STRING_H
    #undef HAVE_SYS_SOCKET_H
    #undef HAVE_UNISTD_H
    #undef HAVE_NONEXIST_H
  #+end_src
- example of config.h generated by autoconf
  #+begin_src c
    /* config.h.  Generated from config.h.in by configure.  */
    #define HAVE_NETINET_IN_H 1
    #define HAVE_STDINT_H 1
    #define HAVE_STDIO_H 1
    #define HAVE_STDLIB_H 1
    #define HAVE_STRING_H 1
    #define HAVE_SYS_SOCKET_H 1
    #define HAVE_UNISTD_H 1
    /* #undef HAVE_NONEXIST_H */
  #+end_src

** Makefile.am
In order to generate Makefile file, we need a Makefile template, here we create two Makefile.am in
test and test/src directory. Let's look at the Makefile.am in test directory first.
#+begin_src example
  SUBDIRS = src
#+end_src

Then we look at the Makefile.am in test/src
#+begin_src example
  bin_PROGRAMS = client server
  client_SOURCES = client.c
  server_SOURCES = server.c
#+end_src

Now we need to create some files: AUTHORS, COPYING, NEWS, ChangeLog and README, these files are
standard GNU project files and automake will check these files, so you have to create them before
run automake, but if you don't want to create them you can add "foreign" flag in Makefile.am like
this.
#+begin_src example
  AUTOMAKE_OPTIONS=foreign
  bin_PROGRAMS = client server
  client_SOURCES = client.c
  server_SOURCES = server.c
#+end_src

In the end, we add AM_INIT_AUTOMAKE to initialize automake, and replace AC_CONFIG_FILES([Makefile
src/Makefile])
#+begin_src example
  #-*- Autoconf -*-
  # Process this file with autoconf to produce a configure script.

  AC_PREREQ([2.68])
  AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])
  AC_CONFIG_SRCDIR([src/server.c])
  AC_CONFIG_HEADERS([config.h])
  AM_INIT_AUTOMAKE([-Wno-portability])

  # Checks for programs.
  AM_PROG_CC_C_O

  # Checks for libraries.

  # Checks for header files.
  AC_CHECK_HEADERS([netinet/in.h stdlib.h strings.h sys/socket.h unistd.h])

  # Checks for typedefs, structures, and compiler characteristics.
  AC_TYPE_PID_T

  # Checks for library functions.
  AC_FUNC_FORK
  AC_FUNC_MALLOC
  AC_CHECK_FUNCS([bzero socket])

  AC_CONFIG_FILES([Makefile])
  AC_OUTPUT
#+end_src

** Programs and Libraries with Automake
INCLUDES = -I/dir1 -I/dir2 -I/dir3 ....
LDFLAGS = -L/dir1 -L/dir2 -L/dir3 ....
LDADD = -llib1 -llib2 -llib3 ...
If your package contains subdirectories with libraries and you want to link these libraries in
another subdirectory you need to put `-I' and `-L' flags in the two variables above. To express the
path to these other subdirectories, use the `$(top_srcdir)' variable. For example if you want to
access a library under `src/libfoo' you can put something like:
INCLUDES = ... -I$(top_srcdir)/src/libfoo ...
LDFLAGS  = ... -L$(top_srcdir)/src/libfoo ...
on the `Makefile.am' of every directory level that wants access to these libraries. Also, you must
make sure that the libraries are built before the directory level is built. To guarantee that, list
the library directories in `SUBDIRS' before the directory levels that depend on it. One way to do
this is to put all the library directories under a `lib' directory and all the executable
directories under a `bin' directory and on the `Makefile.am' for the directory level that contains
`lib' and `bin' list them as:
SUBDIRS = lib bin
This will guarantee that all the libraries are available before building any
executables. Alternatively, you can simply order your directories in such a way so that the library
directories are built first.
Next we list the things that are to be built in this directory level:
bin_PROGRAMS    = prog1 prog2 prog3 ....
lib_LIBRARIES   = libfoo1.a libfoo2.a libfoo3.a ....
check_PROGRAMS  = test1 test2 test3 ....
TESTS           = $(check_PROGRAMS)
include_HEADERS = header1.h header2.h ....
The `bin_PROGRAMS' line lists all the executable files that will be compiled with make and installed
with make install under `/prefix/bin', where `prefix' is usually `/usr/local'.The `lib_LIBRARIES'
line lists all the library files that will be compiled with make and installed with make install
under `/prefix/lib'. The `check_PROGRAMS' line lists executable files that are not compiled with a
simple make but only with a make check. These programs serve as tests that you, the user can use to
test the library. The `TESTS' line lists executable files which are to be compiled and executed when
you run make check. These programs constitute the test suite and they are indispensable when you
develop a library. It is common to just set
TESTS = $(check_PROGRAMS)
This way by commenting the line in and out, you can modify the behaviour of make check. While
debugging your test suite, you will want to comment out this line so that make check doesn't run
it. However, in the end product, you will want to comment it back in.
The `include_HEADERS' line lists public headers present in this directory that you want to install
in /prefix/include. You must list a header file here if you want to cause it to be installed. You
can also list it under libfoo_a_SOURCES for the library that it belongs to, but it is imperative to
list public headers here so that they can be installed. It is good programming practice to keep
libraries and executables under separate directory levels. However, it is okey to keep the library
and the check executables that test the library under the same directory level because that makes it
easier for you to link them with the library. For each of these types of targets, we must state
information that will allow automake and make to infer the building process. For each Program: You
need to declare the set of files that are sources of the program, the set of libraries that must be
linked with the program and (optionally) a set of dependencies that need to be built before the
program is built. These are declared in assignments that look like this:
prog1_SOURCES = foo1.cc foo2.cc ... header1.h header2.h ....
prog1_LDADD   = -lbar1 -lbar2 -lbar3
prog1_LDFLAGS = -L/dir1 -L/dir2 -L/dir3 ...
prog1_DEPENDENCIES = dep1 dep2 dep3 ...
In each assignment substitute `prog1' with the name of the program that you are building as it
appeared in `bin_PROGRAMS' or `check_PROGRAMS'.
- `prog1_SOURCES': Here you list all the `*.cc' and `*.h' files that compose the source code of the
  program. The presence of a header file here doesn't cause the file to be installed at
  `/prefix/include' but it does cause it to be added to the distribution when you do make dist. To
  cause header files to be installed you must also put them in `include_HEADERS'.

- `prog1_LDADD': Here you add primarily the -l flags for linking whatever libraries are needed by
  your code. You may also list object files, which have been compiled in an exotic way, as well as
  paths to uninstalled yet libraries.

- `prog_LDFLAGS': Here you add the -L flags that are needed to resolve the libraries you passed in
  `prog_LDADD'. Certain flags that need to be passed on every program can be expressed on a global
  basis by assigning them at `LDFLAGS'.

- `prog1_DEPENDENCIES': If for any reason you want certain other targets to be built before building
  this program, you can list them here.

This is all you need to do. There is no need to write an extended Makefile with all the targets,
dependencies and rules that are required to build the program. They are computed for you by this
minimal information by `automake'. Moreover, the targets `dist', `install', `clean' and `distclean'
are appropriately setup to handle the program. You don't need to take care of them by yourself.
For each Library: There's a total of four assignments that are relevant to building libraries:

lib_LIBRARIES = ... libfoo1.a ...
libfoo1_a_SOURCES      = foo1.cc foo2.cc private1.h private2.h ...
libfoo1_a_LIBADD       = obj1.o obj2.o obj3.o
libfoo1_a_DEPENDENCIES = dep1 dep2 dep3 ...
Note that if the name of the library is `libfoo1.a' the prefix that appears in the variables that
are related with that library is `libfoo1_a_'.

- `libfoo1_a_SOURCES': Just like with programs, here you list all the `*.cc' files as well as all
  the private header files that compose the library. By private header file we mean a header file
  that is used internally by the library and the maintainers of the library, but is not exported to
  the end-user. You can list public header files also if you like, and perhaps you should for
  documentation purposes, but if you mention them in include_HEADERS it is not required to repeat
  them a second time here.

- `libfoo1_a_DEPENDENCIES': If there are any other targets that need to be built before this library
  is built, list them here.

- `libfoo1_a_LIBADD': If there are any other object files that you want to include in the library
  list them here. You might be tempted to list them as dependencies in `libfoo1_a_DEPENDENCIES', but
  that will not work. If you do that, the object files will be built before the library is built but
  they will not be included in the library! By listing an object file here, you are stating that you
  want it to be built and you want it to be included in the library.

** Conclusion
Now we know how to create an auto-build system to compile our project
1. aclocal
2. autoconf
3. autoheader
4. automake -a -c
5. ./configure
6. make
